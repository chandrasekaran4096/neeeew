Perfect — your setup is well-structured 👏 and you’re very close.
The reason you’re getting `alert("Failed to reorder.")` even though your logic looks fine is **most likely because the SQL in your `copyOrderItemsToCart()` method is incomplete** — it doesn’t join with the `M_D_MENU` table to fetch `menu_id` correctly.

Let’s go through the reasoning carefully 👇

---

### ⚠️ Problem Explanation

In your `OrderDAO.copyOrderItemsToCart()`:

```java
String sql = "INSERT INTO food.M_D_CART (userid, menu_id, quantity, is_deleted) " +
             "SELECT ?, menu_id, quantity, 0 FROM food.M_D_ORDER_ITEM WHERE order_id = ?";
```

But in your schema:

* `menu_id` is **in `M_D_ORDER_ITEM`**, okay ✅
* However, depending on how your DB is structured, there might also be a **foreign key** constraint requiring a valid `restaurant_id` or other columns like `price`, etc., in `M_D_CART`.

So if your `M_D_CART` has columns like:

```
(cart_id, userid, menu_id, quantity, restaurant_id, is_deleted)
```

then this insert query will **fail silently** (constraint violation) and return `false`.
That’s why you see **“Failed to reorder”** even though the code is running fine.

---

### ✅ Fix 1 — Add Missing Restaurant ID (most likely the issue)

Change your `copyOrderItemsToCart()` to include `restaurant_id` by joining with `M_D_MENU`:

```java
public boolean copyOrderItemsToCart(int userId, int orderId) {
    String sql = "INSERT INTO food.M_D_CART (userid, menu_id, quantity, restaurant_id, is_deleted) " +
                 "SELECT ?, oi.menu_id, oi.quantity, m.restaurant_id, 0 " +
                 "FROM food.M_D_ORDER_ITEM oi " +
                 "JOIN food.M_D_MENU m ON oi.menu_id = m.menu_id " +
                 "WHERE oi.order_id = ?";
    try (Connection con = DBConnection.getConnection();
         PreparedStatement ps = con.prepareStatement(sql)) {
        ps.setInt(1, userId);
        ps.setInt(2, orderId);
        int rows = ps.executeUpdate();
        return rows > 0;
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return false;
}
```

✅ This ensures all required fields are inserted correctly.

---

### ✅ Fix 2 — Add JSON content type in servlet

In your `ReorderServlet.java`, before writing the response, add:

```java
resp.setContentType("application/json");
```

Otherwise, jQuery may treat it as plain text and `res.success` could become undefined.

Final servlet:

```java
package com.bite.controller;

import com.bite.service.OrderService;
import javax.servlet.http.*;
import java.io.IOException;

public class ReorderServlet extends HttpServlet {
    private final OrderService orderService = new OrderService();

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.setContentType("application/json");

        int orderId = Integer.parseInt(req.getParameter("orderId"));
        HttpSession session = req.getSession(false);
        if (session == null || session.getAttribute("user") == null) {
            resp.getWriter().write("{\"success\":false}");
            return;
        }

        int userId = ((com.bite.model.User) session.getAttribute("user")).getUserId();
        boolean success = orderService.reorder(userId, orderId);
        resp.getWriter().write("{\"success\":" + success + "}");
    }
}
```

---

### ✅ Fix 3 — Add console logs in JS for debugging

Before the alert, add:

```js
console.log("Reorder response:", res);
```

If you see plain text like `{"success":true}` in console instead of a parsed object,
update your AJAX call to explicitly expect JSON:

```js
$.ajax({
  url: "http://localhost:8080/BiteBudddy/ReorderServlet",
  method: "POST",
  data: { orderId: id },
  dataType: "json", // 👈 ensure it parses JSON
  success: function (res) {
    console.log("Reorder response:", res);
    if (res.success) {
      alert("Items added to your cart!");
      window.location.href = "cart.html";
    } else {
      alert("Failed to reorder.");
    }
  },
  error: function () {
    alert("Server error during reorder.");
  }
});
```

---

### ✅ Optional Debug Check (in SQL console)

Run this manually in your DB to confirm:

```sql
SELECT * FROM food.M_D_ORDER_ITEM WHERE order_id = <your_order_id>;
```

and then:

```sql
SELECT * FROM food.M_D_CART;
```

If nothing new appears, it confirms the insert query failed — meaning the column mismatch or constraint problem caused the issue.

---

### ✅ Summary of Fixes

| Issue                             | Fix                                           |
| --------------------------------- | --------------------------------------------- |
| Missing `restaurant_id` in insert | Join `M_D_MENU` table                         |
| JSON response not parsed          | Add `dataType: "json"`                        |
| No response type                  | Add `resp.setContentType("application/json")` |
| Debugging clarity                 | Add `console.log(res)`                        |

---

Would you like me to make the **reorder** also check if the items are from the **same restaurant** as the current cart (to prevent mixing from different restaurants)? That’s a common real-world rule in food delivery systems.


com.microsoft.sqlserver.jdbc.SQLServerException: Invalid column name 'restaurant_id'.
	at com.microsoft.sqlserver.jdbc.SQLServerException.makeFromDatabaseError(SQLServerException.java:262)
	at com.microsoft.sqlserver.jdbc.SQLServerStatement.getNextResult(SQLServerStatement.java:1632)
	at com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement.doExecutePreparedStatement(SQLServerPreparedStatement.java:602)
	at com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement$PrepStmtExecCmd.doExecute(SQLServerPreparedStatement.java:524)
	at com.microsoft.sqlserver.jdbc.TDSCommand.execute(IOBuffer.java:7375)
	at com.microsoft.sqlserver.jdbc.SQLServerConnection.executeCommand(SQLServerConnection.java:3206)
	at com.microsoft.sqlserver.jdbc.SQLServerStatement.executeCommand(SQLServerStatement.java:247)
	at com.microsoft.sqlserver.jdbc.SQLServerStatement.executeStatement(SQLServerStatement.java:222)
	at com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement.executeUpdate(SQLServerPreparedStatement.java:473)
	at com.bite.dao.OrderDAO.copyOrderItemsToCart(OrderDAO.java:122)
	at com.bite.service.OrderService.reorder(OrderService.java:37)
	at com.bite.controller.ReorderServlet.doPost(ReorderServlet.java:22)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:555)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:623)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:199)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:144)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:168)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:144)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:168)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:130)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:656)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:346)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:397)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:935)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1833)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:975)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:493)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:832)

