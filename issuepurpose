Perfect — your setup is well-structured 👏 and you’re very close.
The reason you’re getting `alert("Failed to reorder.")` even though your logic looks fine is **most likely because the SQL in your `copyOrderItemsToCart()` method is incomplete** — it doesn’t join with the `M_D_MENU` table to fetch `menu_id` correctly.

Let’s go through the reasoning carefully 👇

---

### ⚠️ Problem Explanation

In your `OrderDAO.copyOrderItemsToCart()`:

```java
String sql = "INSERT INTO food.M_D_CART (userid, menu_id, quantity, is_deleted) " +
             "SELECT ?, menu_id, quantity, 0 FROM food.M_D_ORDER_ITEM WHERE order_id = ?";
```

But in your schema:

* `menu_id` is **in `M_D_ORDER_ITEM`**, okay ✅
* However, depending on how your DB is structured, there might also be a **foreign key** constraint requiring a valid `restaurant_id` or other columns like `price`, etc., in `M_D_CART`.

So if your `M_D_CART` has columns like:

```
(cart_id, userid, menu_id, quantity, restaurant_id, is_deleted)
```

then this insert query will **fail silently** (constraint violation) and return `false`.
That’s why you see **“Failed to reorder”** even though the code is running fine.

---

### ✅ Fix 1 — Add Missing Restaurant ID (most likely the issue)

Change your `copyOrderItemsToCart()` to include `restaurant_id` by joining with `M_D_MENU`:

```java
public boolean copyOrderItemsToCart(int userId, int orderId) {
    String sql = "INSERT INTO food.M_D_CART (userid, menu_id, quantity, restaurant_id, is_deleted) " +
                 "SELECT ?, oi.menu_id, oi.quantity, m.restaurant_id, 0 " +
                 "FROM food.M_D_ORDER_ITEM oi " +
                 "JOIN food.M_D_MENU m ON oi.menu_id = m.menu_id " +
                 "WHERE oi.order_id = ?";
    try (Connection con = DBConnection.getConnection();
         PreparedStatement ps = con.prepareStatement(sql)) {
        ps.setInt(1, userId);
        ps.setInt(2, orderId);
        int rows = ps.executeUpdate();
        return rows > 0;
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return false;
}
```

✅ This ensures all required fields are inserted correctly.

---

### ✅ Fix 2 — Add JSON content type in servlet

In your `ReorderServlet.java`, before writing the response, add:

```java
resp.setContentType("application/json");
```

Otherwise, jQuery may treat it as plain text and `res.success` could become undefined.

Final servlet:

```java
package com.bite.controller;

import com.bite.service.OrderService;
import javax.servlet.http.*;
import java.io.IOException;

public class ReorderServlet extends HttpServlet {
    private final OrderService orderService = new OrderService();

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.setContentType("application/json");

        int orderId = Integer.parseInt(req.getParameter("orderId"));
        HttpSession session = req.getSession(false);
        if (session == null || session.getAttribute("user") == null) {
            resp.getWriter().write("{\"success\":false}");
            return;
        }

        int userId = ((com.bite.model.User) session.getAttribute("user")).getUserId();
        boolean success = orderService.reorder(userId, orderId);
        resp.getWriter().write("{\"success\":" + success + "}");
    }
}
```

---

### ✅ Fix 3 — Add console logs in JS for debugging

Before the alert, add:

```js
console.log("Reorder response:", res);
```

If you see plain text like `{"success":true}` in console instead of a parsed object,
update your AJAX call to explicitly expect JSON:

```js
$.ajax({
  url: "http://localhost:8080/BiteBudddy/ReorderServlet",
  method: "POST",
  data: { orderId: id },
  dataType: "json", // 👈 ensure it parses JSON
  success: function (res) {
    console.log("Reorder response:", res);
    if (res.success) {
      alert("Items added to your cart!");
      window.location.href = "cart.html";
    } else {
      alert("Failed to reorder.");
    }
  },
  error: function () {
    alert("Server error during reorder.");
  }
});
```

---

### ✅ Optional Debug Check (in SQL console)

Run this manually in your DB to confirm:

```sql
SELECT * FROM food.M_D_ORDER_ITEM WHERE order_id = <your_order_id>;
```

and then:

```sql
SELECT * FROM food.M_D_CART;
```

If nothing new appears, it confirms the insert query failed — meaning the column mismatch or constraint problem caused the issue.

---

### ✅ Summary of Fixes

| Issue                             | Fix                                           |
| --------------------------------- | --------------------------------------------- |
| Missing `restaurant_id` in insert | Join `M_D_MENU` table                         |
| JSON response not parsed          | Add `dataType: "json"`                        |
| No response type                  | Add `resp.setContentType("application/json")` |
| Debugging clarity                 | Add `console.log(res)`                        |

---

Would you like me to make the **reorder** also check if the items are from the **same restaurant** as the current cart (to prevent mixing from different restaurants)? That’s a common real-world rule in food delivery systems.
